"""
This program will sort numbers with different algorithms and tell you how long it took and the number of swaps (time.time) I need 4+ algorithms
Users needs to be able to input their own array of numbers or generate a random list, view the step by step process, choose which algorithm is used, see supported array, and see number of comparisons/swaps

To do:
    Fix time
    Double check comparison/swap numbers
    Fix bucket sort

"""

def selection_sort(listed, show_steps):
    pass

def insertion_sort(listed, show_steps, bs = False):
    if show_steps == True: 
        print("Insertion sort works by finding the smallest number first and then putting it in its spot and then repeating that process with the next smallest and so on. \n")
    iterations = 0
    returned = []
    while True:
        if show_steps == True: 
            print(f"The first unsorted item in the list is {listed[0]}, so we start by assuming that's the smallest. \n")
        temp = listed[0]
        for value in listed:
            if value < temp:
                if show_steps == True: 
                    print(f"{value} is smaller than {temp} so we assume it's the smallest for now. Then we move onto the next item. \n")
                temp = value
            else:
                if show_steps == True: 
                    print(f"{value} is not smaller than {temp} so we move onto the next item. \n")
        if show_steps == True: 
            print(f"We've gone all the way through the list and {temp} was the smallest so we put it in its spot. \n\n")

        listed.pop(listed.index(temp))
        returned.append(temp)
        shown = returned.copy()
        shown.extend(listed)
        if show_steps == True: 
            print(f"The list is now {shown}\n\n")

        iterations += 1

        if listed == []:
            print(f"The insertion sort took {iterations} laps to sort the list. The list is now {returned}. \n\n")

            if bs == True:
                return (returned, iterations)
            else:
                return returned


def bucket_sort(listed, show_steps):
    list1 = [] #Less than five
    list2 = [] #Greater than or equal to five

    if show_steps == True: 
        print("Bucket sort starts by dividing the elements into lists. In this case we'll use two categories or 'buckets'. \n\n")

    for value in listed:
        if value < 5:
            list1.append(value)
            if show_steps == True:
                print(f"Since {value} is less than five, it goes in the first list. \n")
        elif value >= 5:
            list2.append(value)
            if show_steps == True:
                print(f"Since this value is equal to or greater than five, it goes in the second list. \n")
    if show_steps == True:
        print(f"Then we sort the lists using insertion sort. \n")

    if len(list1) >= 1: 
        if show_steps == True:
            print("The less than five list is sorted first. \n")
        list1 = insertion_sort(list1, show_steps, True)
        iterations = list1[1]
        list1 = list1[0]
    else:
        print("The first list is empty, so we don't sort it. ")

    if len(list1) >= 1: 
        if show_steps == True:
            print("The greater than or equal to five list is sorted next. \n")
        list2 = insertion_sort(list2, show_steps, True)
        iterations += list2[1]
        list2 = list2[0]
    else:
        print("The second list is empty, so we don't sort it. ")


    if show_steps == True:
        print("Then the two sorted lists are put together. \n")
    
    print(list1)
    print(list2)

    listed = list1
    listed.extend(list2)

    print(f"The list is now sorted. The final list is {listed}. The sort took {iterations} iterations to complete. \n")
    return listed

    
def pigeon_sort(listed, show_steps):
    returned = []
    dictionary = {1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0, 10:0, }
    if show_steps == True:
        print("Pigeon sort works by putting elements (pigones) in specific spots (pigeonholes). \n")
    for value in listed:
        dictionary[value] += 1
        if show_steps == True:
            print(f"The next value is {value}, so we put it in its box. Now there are {dictionary[value]} {value}(s) in the box. \n")
    if show_steps == True:
        print("Then we put all the values back in the list. \n")

    for key in dictionary:
        for num in range(dictionary[key]):
            if dictionary[key] == 1: 
                if show_steps == True:
                    print(f"The first box with a pigeon in it is {key} and there is {dictionary[key]} of them. \n")
            else:
                if show_steps == True:
                    print(f"The first box with a pigeon in it is {key} and there are {dictionary[key]} of them. \n")
            returned.append(key)
    print(f"The list is now {returned}. \n")
    return returned


def bubble_sort(listed, show_steps):
    swaps = 0
    total_swaps = 0
    if show_steps == True:
        print("Bubble sort works by continously swapping elements so the smaller one goes first. \n")
    index = 0
    if show_steps == True:
        print("We start at the beginning of the list. \n")

    while True:
        # print("Made it into the first loop! ")
        
        # print(str(index) + " is the index")

        if listed[index] > listed[index + 1]:
            # print("Made it past comparison! ")
            if show_steps == True:
                print(f"{listed[index]} is greater than {listed[index + 1]}, so they swap. \n")
            temp = listed[index]
            listed[index] = listed[index + 1]
            listed[index + 1] = temp
            swaps += 1
            total_swaps += 1
            index += 1
        elif listed[index] <= listed[index +1]:
            if show_steps == True:
                print(f"Since {listed[index]} is not bigger than {listed[index + 1]}, the both stay where they are. \n")
            index += 1
        else:
            print("An error occured. \n")
            break
        
        
        
        if index == len(listed) - 1 and swaps == 0:
            if show_steps == True:
                print("The list is now sorted. ")
            print(f"The list is {listed}. It took {total_swaps} swaps to complete. ")
            return listed
        elif index == len(listed) - 1:
            if show_steps == True:
                print("This is the end of the list, so we go back. \n\n")
            index = 0
            swaps = 0
        
        # non_existant = input("This is to pause the freaking thing")


import random

listed = []

def get_list(): 
    while True: 
        inputed = input("Do you want to A) Insert your own numbers between one and ten or B) Have a random list generated. \n")
        inputed = inputed.strip().lower()
        if inputed == "a":
            # print("Input your own number or enter 'end' to stop. ")
            inputed = 4
            while True:
                inputed = int(input("Input your own number or enter '0' to stop. \n"))
                if inputed <= 10 and inputed > 0: 
                    listed.append(inputed)
                elif inputed == 0:
                    print("Your list is" + str(listed) +"\n")
                    return listed
                else:
                    print("Invalid option\n")

        elif inputed == "b":
            x = random.randrange(3,9)
            for i in range(x):
                listed.append(random.randrange(1,10))
            print("Your list is" + str(listed))
            return listed

        else:
            print("Invalid input. ")

listed = get_list()
import time

while True:
    inputed = input("Pick a sorting method A) Selection sort B) Insertion sort C) Bucket sort D) Pigeon Sort E) Bubble sort\n")
    inputed = inputed.strip().lower()

    while True: 
        show_steps = input("Do you want to see the step by step sort? (y or n)? \n").strip().lower()

        if show_steps == "y":
            show_steps = True
            break
        elif show_steps == "n":
            show_steps = False
            break
        else:
            print("Invalid answer. \n")

    start = time.gmtime(0) 

    if inputed == "a":
        epoch = time.asctime(start) 
        selection_sort(listed, show_steps)
        time = time.time()
        break
    elif inputed == "b":
        epoch = time.asctime(start) 
        insertion_sort(listed, show_steps)
        time = time.time()
        break
    elif inputed == "c":
        epoch = time.asctime(start) 
        bucket_sort(listed, show_steps)
        time = time.time()
        break
    elif inputed == "d":
        epoch = time.asctime(start) 
        pigeon_sort(listed, show_steps)
        time = time.time()
        break
    elif inputed == "e":
        epoch = time.asctime(start) 
        bubble_sort(listed, show_steps)
        time = time.time()
        break
    else: 
        print("Invalid option. \n")

print(f"The algorithm took {time} seconds to complete. \n")